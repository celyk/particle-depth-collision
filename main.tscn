[gd_scene load_steps=29 format=2]

[ext_resource path="res://look_and_fly.gd" type="Script" id=1]
[ext_resource path="res://particles.gdshader" type="Shader" id=2]
[ext_resource path="res://particle.tres" type="Material" id=4]
[ext_resource path="res://smooth_follow.gd" type="Script" id=5]
[ext_resource path="res://resize_viewport.gd" type="Script" id=6]

[sub_resource type="ProceduralSky" id=1]

[sub_resource type="Environment" id=37]
background_sky = SubResource( 1 )
ambient_light_color = Color( 0, 0.0705882, 0.27451, 1 )
ambient_light_sky_contribution = 0.5
ssao_enabled = true
ssao_radius = 0.2
ssao_radius2 = 1.0
ssao_light_affect = 1.0
ssao_ao_channel_affect = 1.0
glow_enabled = true
glow_intensity = 1.0
glow_strength = 1.64
glow_hdr_luminance_cap = 31.2
glow_bicubic_upscale = true

[sub_resource type="ViewportTexture" id=25]
viewport_path = NodePath("Viewport")

[sub_resource type="ShaderMaterial" id=19]
resource_local_to_scene = true
render_priority = 2
shader = ExtResource( 2 )
shader_param/spray = 0.4
shader_param/bounciness = 0.5
shader_param/friction = 0.0
shader_param/start_velocity = null
shader_param/my_screen_pixel_size = null
shader_param/my_camera = null
shader_param/my_scuffed_projection = null
shader_param/tex = SubResource( 25 )

[sub_resource type="PlaneMesh" id=36]
material = ExtResource( 4 )

[sub_resource type="GDScript" id=17]
script/source = "extends Particles

onready var last_pos = global_translation
var last_camera_transform : Transform

# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(dt):
	#process_material.set_shader_param(\"tex\",get_viewport().get_texture())
	
	process_material.set_shader_param(\"my_screen_pixel_size\",Vector2(1,1)/get_viewport().size)
	
	var camera = get_viewport().get_camera()
	var camera_transform = camera.get_camera_transform()
	process_material.set_shader_param(\"my_camera\",camera_transform)
	
	var aspect = get_viewport().size.x/get_viewport().size.y
	process_material.set_shader_param(
		\"my_scuffed_projection\",
		ProjectionMatrix.createProjectionMatrix(camera.fov,aspect,camera.near,camera.far))
	

	var velocity = (global_translation - last_pos)/dt
	
	emitting = false
	if Input.is_mouse_button_pressed(BUTTON_LEFT):
		emitting = true
		#velocity += -global_transform.basis[2]*4.0
	process_material.set_shader_param(\"start_velocity\",velocity)
	
	
	var D_inv_camera = camera_transform.inverse() #(camera_transform - last_camera_transform)/dt
	last_camera_transform = last_camera_transform.inverse()
	for i in range(0,4): 
		D_inv_camera[i] = (D_inv_camera[i] - last_camera_transform[i])/dt
	#print(dcamera)
	
	draw_pass_1.material.set_shader_param(\"D_inv_camera\",D_inv_camera)
	
	last_pos = global_translation
	last_camera_transform = camera_transform
"

[sub_resource type="SpatialMaterial" id=23]
albedo_color = Color( 0.235294, 0.235294, 0.235294, 1 )

[sub_resource type="Shader" id=15]
code = "shader_type spatial;

render_mode unshaded;//depth_test_disable;

vec3 getWorldPos(vec2 screen, float depth, mat4 clipToView, mat4 viewToWorld){
	vec3 ndc = vec3(screen, depth) * 2.0 - 1.0;
	/*vec4 view = clipToView * vec4(ndc, 1.0);
	view.xyz /= view.w;
	float linear_depth = -view.z;*/

	vec4 world = viewToWorld * clipToView * vec4(ndc, 1.0);
	vec3 world_position = world.xyz / world.w;
	
	return world_position;
}

void fragment(){
	ALBEDO = vec3(.2);
	//float depth = texture(DEPTH_TEXTURE,SCREEN_UV).x;
	//ALBEDO = getWorldPos(SCREEN_UV,depth,inverse(PROJECTION_MATRIX),CAMERA_MATRIX);
}"

[sub_resource type="ShaderMaterial" id=16]
render_priority = -1
shader = SubResource( 15 )

[sub_resource type="Shader" id=8]
code = "shader_type spatial;

render_mode unshaded,depth_test_disable,blend_mul;

void fragment(){
	ALBEDO = vec3(1);
	ALPHA = textureLod(DEPTH_TEXTURE,SCREEN_UV,0.).x;
}"

[sub_resource type="ShaderMaterial" id=38]
render_priority = 1
shader = SubResource( 8 )

[sub_resource type="Shader" id=26]
code = "shader_type particles;

render_mode disable_velocity;

uniform sampler2D tex;

uniform vec2 my_screen_pixel_size;

uniform mat4 my_camera;
uniform mat4 my_scuffed_projection;

mat2 rotate(float a) {
    float s = sin(a), c = cos(a);
    return mat2(vec2(c, -s), vec2(s, c));
}

float rand_from_seed(inout uint seed) {
	int k;
	int s = int(seed);
	if (s == 0)
	s = 305420679;
	k = s / 127773;
	s = 16807 * (s - k * 127773) - 2836 * k;
	if (s < 0)
		s += 2147483647;
	seed = uint(s);
	return float(seed % uint(65536)) / 65535.0;
}

uint hash(uint x) {
	x = ((x >> uint(16)) ^ x) * uint(73244475);
	x = ((x >> uint(16)) ^ x) * uint(73244475);
	x = (x >> uint(16)) ^ x;
	return x;
}


vec2 getUV(vec3 pos,mat4 viewToClip, mat4 worldToView){
	vec4 p = viewToClip*worldToView*vec4(pos,1);
	p.xyz /= p.w;
	return p.xy*.5+.5;
}

vec3 getWorldPos(vec2 screen, float depth, mat4 clipToView, mat4 viewToWorld){
	vec3 ndc = vec3(screen, depth) * 2.0 - 1.0;
	/*vec4 view = clipToView * vec4(ndc, 1.0);
	view.xyz /= view.w;
	float linear_depth = -view.z;*/
	
	vec4 world = viewToWorld * clipToView * vec4(ndc, 1.0);
	vec3 world_position = world.xyz / world.w;
	
	return world_position;
}

void vertex(){
	// random vector
	uint base_number = NUMBER;
	uint alt_seed = hash(base_number + uint(1) + RANDOM_SEED);

	vec3 rv = vec3(rand_from_seed(alt_seed),rand_from_seed(alt_seed),rand_from_seed(alt_seed))-.5;
	
	vec3 a = EMISSION_TRANSFORM[3].xyz + normalize(rv)*.1;
	vec3 b = a;
	
	float r = .001;
	
	if(RESTART){
		CUSTOM.w = 0.;
		COLOR.xyz = vec3(rv+.5);
		TRANSFORM = mat4(r);
		TRANSFORM[2].xyz = a;
		TRANSFORM[3].xyz = a;
		CUSTOM.x = 1.0;
	}
	else{
		if(CUSTOM.x > .5){
			// reconstruct projection matrix
			mat4 my_projection = my_scuffed_projection;
			my_projection[2][3] = -1.;
			my_projection[3][3] = 0.;
			
			// get screen space coordinates of particle
			vec2 uv = getUV(TRANSFORM[3].xyz,my_projection,inverse(my_camera));
			vec4 T = textureLod(tex,uv,0.);
			
			vec3 scene_pos = getWorldPos(uv,T.w,inverse(my_projection),my_camera);

			float scene_t = length(scene_pos - my_camera[3].xyz);
			float particle_t = length(TRANSFORM[3].xyz - my_camera[3].xyz);
			
			vec3 view = normalize(scene_pos - my_camera[3].xyz);
			
			float penetration_depth = scene_t - particle_t;
			bool colliding = penetration_depth <= 0.; // && penetration_depth >= -length(VELOCITY)*.1;
			
			// handle collision
			if(colliding){
				CUSTOM.x = 0.;
				COLOR.xyz = vec3(1,0,0);
				
				//b = TRANSFORM[3].xyz;
				/*TRANSFORM[0].xyz = (b-a)/2.;
				TRANSFORM[1].xyz = r*normalize( cross(TRANSFORM[0].xyz,vec3(0,1,0)) );
				TRANSFORM[2].xyz = r*normalize( cross(TRANSFORM[0].xyz,TRANSFORM[1].xyz) );
				TRANSFORM[3].xyz = (a+b)/2.;*/
			}
		}
		// simulate
		
		CUSTOM.w += DELTA;
		
		// integrate gravity acceleration
		//VELOCITY += vec3(0,-2,0)*DELTA;
		
		// random vector
		base_number = NUMBER + uint(CUSTOM.w*1000.);
		alt_seed = hash(base_number + uint(1) + RANDOM_SEED);

		rv = vec3(rand_from_seed(alt_seed),rand_from_seed(alt_seed),rand_from_seed(alt_seed))-.5;
		
		if(CUSTOM.x>.5){
			TRANSFORM[3].xyz += rv*.05;
		}
		
		COLOR.w = smoothstep(LIFETIME,LIFETIME-.5,CUSTOM.w)*.5;
		
	}
}"

[sub_resource type="ShaderMaterial" id=27]
resource_local_to_scene = true
render_priority = 2
shader = SubResource( 26 )
shader_param/my_screen_pixel_size = null
shader_param/my_camera = null
shader_param/my_scuffed_projection = null
shader_param/tex = SubResource( 25 )

[sub_resource type="Shader" id=31]
code = "shader_type spatial;

render_mode unshaded,skip_vertex_transform,cull_disabled;

vec3 xform(mat4 T,vec3 p,int w){
	return (T*vec4(p,float(w))).xyz;
}

// calculates line billboard in view space
mat4 getLineBillboard(vec3 a,vec3 b){
	mat4 billboard = mat4(1);
	billboard[1].xyz = (b-a)/2.;
	billboard[0].xyz = normalize( cross(a,b) );
	billboard[3].xyz = (b+a)/2.;
	return billboard;
}

// calculates billboarding curve point basis in view space
mat4 getCurvedBillboard(vec3 p,vec3 v){
	mat4 M = mat4(1);
	M[0].xyz = v;
	M[1].xyz = normalize( cross(v,p) );
	M[2].xyz = normalize( cross(M[0].xyz,M[1].xyz) );
	M[3].xyz = p;
	return M;
}

vec3 p(vec3 a,vec3 b,float t){
	return mix(a,b,t);
}

void vertex(){
	float t = TIME;
	
	//if(INSTANCE_CUSTOM.x < .5){
		vec3 pos = WORLD_MATRIX[3].xyz;
		
		vec3 a = p(WORLD_MATRIX[2].xyz,pos,UV.x);
		vec3 b = p(WORLD_MATRIX[2].xyz,pos,UV.x+.01);
		
		a = xform(INV_CAMERA_MATRIX,a,1);
		b = xform(INV_CAMERA_MATRIX,b,1);
		
		//VERTEX.z = .5;
		//VERTEX = mat3(MODELVIEW_MATRIX)*VERTEX;
	    //NORMAL = normalize(mat3(MODELVIEW_MATRIX)*NORMAL);
		
		VERTEX = VERTEX.xzy;
		VERTEX = xform(getLineBillboard(a,b),VERTEX,1);
	//}
}

void fragment(){
	ALBEDO = COLOR.xyz;
	ALBEDO = vec3(UV,0);
	ALPHA = COLOR.w;
}"

[sub_resource type="ShaderMaterial" id=32]
shader = SubResource( 31 )

[sub_resource type="PlaneMesh" id=30]
material = SubResource( 32 )
size = Vector2( 0.005, 2 )
subdivide_width = 31

[sub_resource type="GDScript" id=28]
script/source = "extends Particles

# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(dt):
	process_material.set_shader_param(\"my_screen_pixel_size\",Vector2(1,1)/get_viewport().size)
	
	var camera = get_viewport().get_camera()
	process_material.set_shader_param(\"my_camera\",camera.get_camera_transform())
	
	var aspect = get_viewport().size.x/get_viewport().size.y
	process_material.set_shader_param(
		\"my_scuffed_projection\",
		ProjectionMatrix.createProjectionMatrix(camera.fov,aspect,camera.near,camera.far))
"

[sub_resource type="PlaneMesh" id=33]
subdivide_width = 255

[sub_resource type="Shader" id=35]
code = "shader_type spatial;

render_mode unshaded,skip_vertex_transform,cull_disabled;

uniform float radius = .01;

vec3 xform(mat4 T,vec3 p,int w){
	return (T*vec4(p,float(w))).xyz;
}

// calculates billboarding curve in view space
mat4 getCurvedBillboard(vec3 p,vec3 v){
	mat4 M;
	M[0].xyz = normalize(v);
	M[1].xyz = normalize( cross(p,M[0].xyz) );
	M[2].xyz = normalize( cross(M[0].xyz,M[1].xyz) );
	M[3].xyz = p;
	return M;
}

vec3 P(float t){
	//t += TIME*.3;
	return vec3(cos(t*7.),sin(t*4.),sin(t*9.))*.3 + cos(t*60.)*.04;
}

varying vec3 p;
varying vec3 v;
void vertex(){
	p = P(UV.x);
	v = (P(UV.x+.001) - p)/.001;
	
	p = xform(INV_CAMERA_MATRIX,p,1);
	v = xform(INV_CAMERA_MATRIX,v,0);
	
	mat4 M = getCurvedBillboard(p,v);
	
	VERTEX = VERTEX.xzy;
	VERTEX.x = 0.;
	VERTEX.y *= radius;
	//VERTEX.y *= 1.-abs(UV.x*2.-1.);
	VERTEX = xform(M,VERTEX,1);
}

void fragment(){
	//vec3 a = xform(INV_CAMERA_MATRIX,P(0.),1);
	//vec3 b = xform(INV_CAMERA_MATRIX,P(1.0),1);
	
	vec2 uv = UV;
	
	uv = abs(uv-.5);
	float d = max(uv.x,uv.y)-.5;
	
	ALPHA = clamp(-d/fwidth(d),0.,1.);
	
	/*vec2 uv = UV;
	uv.y -= .5;
	uv.x *= length(v)/radius*.5;
	uv.x -= .5;
	
	float d = length(uv) - .5;
	if(d>0.&&uv.x<0.){
		discard;
	}*/
	
	if(FRONT_FACING)
		ALBEDO = vec3(1);
	else
		ALBEDO = vec3(0,0,1);
}"

[sub_resource type="ShaderMaterial" id=34]
shader = SubResource( 35 )
shader_param/radius = 0.01

[sub_resource type="Shader" id=6]
code = "shader_type canvas_item;

// colour space conversions taken from godot source code

// This expects 0-1 range input.
vec3 linear_to_srgb(vec3 color) {
    //color = clamp(color, vec3(0.0), vec3(1.0));
    //const vec3 a = vec3(0.055f);
    //return mix((vec3(1.0f) + a) * pow(color.rgb, vec3(1.0f / 2.4f)) - a, 12.92f * color.rgb, lessThan(color.rgb, vec3(0.0031308f)));
    // Approximation from http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html
    return max(vec3(1.055) * pow(color, vec3(0.416666667)) - vec3(0.055), vec3(0.0));
}

// This expects 0-1 range input, outside that range it behaves poorly.
vec3 srgb_to_linear(vec3 color) {
    // Approximation from http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html
    return color * (color * (color * 0.305306011 + 0.682171111) + 0.012522878);
}


vec2 getUV(vec3 pos,mat4 viewToClip, mat4 worldToView){
	vec4 p = viewToClip*worldToView*vec4(pos,1);
	p.xyz /= p.w;
	return p.xy*.5+.5;
}

vec3 getWorldPos(vec2 screen, float depth, mat4 clipToView, mat4 viewToWorld){
	vec3 ndc = vec3(screen, depth) * 2.0 - 1.0;
	/*vec4 view = clipToView * vec4(ndc, 1.0);
	view.xyz /= view.w;
	float linear_depth = -view.z;*/

	vec4 world = viewToWorld * clipToView * vec4(ndc, 1.0);
	vec3 world_position = world.xyz / world.w;
	
	return world_position;
}

vec3 ACESFilm(vec3 x){
	const float a = 2.51;
	const float b = 0.03;
	const float c = 2.43;
	const float d = 0.59;
	const float e = 0.14;
	return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.,1.);
}

void fragment(){
	vec4 T = textureLod(TEXTURE,UV,0.);
	
	vec3 col = T.xyz;
	float depth = T.w;
	
	COLOR.xyz = T.xyz;
	COLOR.w = 1.;
	
	//if(SCREEN_UV.x>.5)
	COLOR.xyz = ACESFilm(COLOR.xyz);
	
	COLOR.xyz = linear_to_srgb(COLOR.xyz); // approximately pow(T.xyz,vec3(1)/2.2)
	
	 // debugging
	/*if(SCREEN_UV.y<.4){
		COLOR.xyz = vec3(depth);
		if(SCREEN_UV.x<.5){
			mat4 aPROJECTION_MATRIX = mat4(1);
			aPROJECTION_MATRIX[0][0] = scuffed_PROJECTION_MATRIX[0];
			aPROJECTION_MATRIX[1][1] = scuffed_PROJECTION_MATRIX[1];
			aPROJECTION_MATRIX[2][2] = scuffed_PROJECTION_MATRIX[2];
			aPROJECTION_MATRIX[2][3] = -1.;
			aPROJECTION_MATRIX[3][2] = scuffed_PROJECTION_MATRIX[3];
			aPROJECTION_MATRIX[3][3] = 0.;
			
			vec3 world_pos = getWorldPos(UV,depth,inverse(aPROJECTION_MATRIX),aCAMERA_MATRIX);
			vec3 n = normalize( cross(dFdx(world_pos),dFdy(world_pos)) );
			
			vec2 uv = getUV(world_pos,aPROJECTION_MATRIX,inverse(aCAMERA_MATRIX));
			//COLOR.xyz = vec3(uv,0);
			COLOR.xyz = n*.5+.5;
		}
	}*/
}"

[sub_resource type="ShaderMaterial" id=7]
shader = SubResource( 6 )

[sub_resource type="ViewportTexture" id=5]
viewport_path = NodePath("Viewport")

[node name="main" type="Spatial"]

[node name="Viewport" type="Viewport" parent="."]
size = Vector2( 1280, 720 )
transparent_bg = true
handle_input_locally = false
use_32_bpc_depth = true
keep_3d_linear = true
script = ExtResource( 6 )

[node name="Camera" type="Camera" parent="Viewport"]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, -0.116796, 0.91955 )
environment = SubResource( 37 )
current = true
fov = 90.0

[node name="Particles" type="Particles" parent="Viewport/Camera"]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0.00173372, 0.0438195, -0.294956 )
emitting = false
amount = 65536
lifetime = 2.5
local_coords = false
process_material = SubResource( 19 )
draw_pass_1 = SubResource( 36 )
script = SubResource( 17 )

[node name="OmniLight" type="OmniLight" parent="Viewport"]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0.246725, -0.938569 )

[node name="CSGCombiner" type="CSGCombiner" parent="Viewport"]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0.371041, 0.220035, -0.274035 )
material_override = SubResource( 23 )

[node name="CSGBox" type="CSGBox" parent="Viewport/CSGCombiner"]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, -0.371041, -0.598761, 0.274035 )
height = 0.230547

[node name="CSGBox2" type="CSGBox" parent="Viewport/CSGCombiner"]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, -0.768323, 0.458627, 0.713085 )
width = 0.344364
height = 1.96502
depth = 0.579155

[node name="CSGBox3" type="CSGBox" parent="Viewport/CSGCombiner"]
width = 0.344364
height = 1.00463
depth = 0.579155

[node name="CSGTorus" type="CSGTorus" parent="Viewport/CSGCombiner"]
inner_radius = 0.357103
outer_radius = 0.601696
sides = 32
ring_sides = 16

[node name="CSGBox4" type="CSGBox" parent="Viewport/CSGCombiner"]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, -0.371041, -0.282762, 0.274035 )
operation = 2
width = 0.709821
height = 0.644568
depth = 0.935899

[node name="CSGTorus2" type="CSGTorus" parent="Viewport/CSGCombiner"]
transform = Transform( 0.400059, 0.0664517, 0, -0.0664517, 0.400059, 0, 0, 0, 0.40554, -0.0712516, -0.348644, 0.563301 )
operation = 2
inner_radius = 1.06863
outer_radius = 2.0468
sides = 16
ring_sides = 24

[node name="CSGTorus3" type="CSGTorus" parent="Viewport/CSGCombiner"]
transform = Transform( 0.397948, 0.0762852, 0.0167749, -0.0774975, 0.396491, 0.0353819, -0.00974504, -0.0379251, 0.403645, -0.0377086, -0.467865, 0.604132 )
operation = 2
inner_radius = 0.605324
outer_radius = 1.04092
sides = 16
ring_sides = 24

[node name="CSGSphere" type="CSGSphere" parent="Viewport/CSGCombiner"]
transform = Transform( 0.0544854, 0, 0, 0, 0.0544854, 0, 0, 0, 0.0544854, -0.574512, -0.29421, 0.0782153 )
radial_segments = 24
rings = 12

[node name="CSGSphere2" type="CSGSphere" parent="Viewport/CSGCombiner"]
transform = Transform( 0.0408215, 0, 0, 0, 0.0408215, 0, 0, 0, 0.0408215, -0.484836, -0.383124, 0.0798078 )
radial_segments = 24
rings = 12

[node name="CSGSphere3" type="CSGSphere" parent="Viewport/CSGCombiner"]
transform = Transform( 0.0408215, 0, 0, 0, 0.0408215, 0, 0, 0, 0.0408215, -0.695278, -0.43328, 0.114599 )
radial_segments = 24
rings = 12

[node name="sky" type="CSGBox" parent="Viewport"]
transform = Transform( 20, 0, 0, 0, 20, 0, 0, 0, 20, 0, 0, 0 )
invert_faces = true
material = SubResource( 16 )

[node name="write_alpha" type="CSGBox" parent="Viewport"]
transform = Transform( 20, 0, 0, 0, 20, 0, 0, 0, 20, 0, 0, 0 )
invert_faces = true
material = SubResource( 38 )

[node name="Particles2" type="Particles" parent="Viewport"]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, -0.359229, -0.130076, -0.215481 )
visible = false
amount = 1
lifetime = 2.5
local_coords = false
process_material = SubResource( 27 )
draw_pass_1 = SubResource( 30 )
script = SubResource( 28 )

[node name="MeshInstance" type="MeshInstance" parent="Viewport"]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, -0.000691175 )
visible = false
mesh = SubResource( 33 )
skeleton = NodePath("../..")
material/0 = SubResource( 34 )

[node name="fly" type="Spatial" parent="."]
unique_name_in_owner = true
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, -0.116796, 0.91955 )
script = ExtResource( 1 )
speed = 0.02
look_sensitivity = 0.3

[node name="camera_pos" type="RemoteTransform" parent="."]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, -0.116796, 0.91955 )
remote_path = NodePath("../Viewport/Camera")
script = ExtResource( 5 )
target_path = NodePath("../fly")
weight = 0.25

[node name="TextureRect" type="TextureRect" parent="."]
material = SubResource( 7 )
anchor_right = 1.0
anchor_bottom = 1.0
texture = SubResource( 5 )
flip_v = true
